/*
COLLECTION 컬렉션
데이터 타입(배열)
같은 데이터 타입을 가진 요소로 구성
여러 ROW를 가질 수 있음.(TABLE)
1.가변 길이 배열(Variable size array(VARRAY))
    TYPE [타입명] IS {VARRAY|VARYING ARRAY}(크기) OF 요소데이터 타입 [NOT NULL];
    선언시에 배열의 전체 크기를 명시.
    순서대로 참조함.
2.중첩 테이블(Nested Table)
    TYPE [타입명] IS TABLE OF 요소데이터 타입 [NOT NULL];
    크기 선언 불필요. 크기 제한이 없음.
    순서대로 참조할 필요없음.
3.연관 배열(Associative Array(INDEX-BY TABLE))
    TYPE [타입명] IS TABLE OF 요소데이터 타입 [NOT NULL]
        INDEX BY[PLS_INTEGER|BINARY_INTEGER|VARCHAR2(크기)];
    키와 값을 쌍으로 타입(HASH MAP와 동일한 개념)
    키->INDEX.

컬렉션 메소드
DELETE, TRIM, EXTEND,EXISTS,FIRST,LAST,COUNT,LIMIT,PRIOR,NEXT
*/

create or replace PROCEDURE PROC_COLLECTION
IS
--타입 선언
    TYPE VARR IS VARRAY(3) OF INTEGER;--INTEGER타입의 요소 3개
    TYPE NEST IS TABLE OF VARCHAR2(10);--VARCHAR2(10) 타입 요소,크기 설정 없음
    TYPE IT_NUMBER IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
    --키 PLS_INTEGER, 값은 NUMBER 타입의 요소
    TYPE IT_STR1 IS TABLE OF VARCHAR2(32) INDEX BY PLS_INTEGER;
    --키 PLS_INTEGER, 값은 VARCHAR2 타입의 요소
    TYPE IT_STR2 IS TABLE OF VARCHAR2(32) INDEX BY VARCHAR2(20);
    --키 VARCHAR2, 값은 VARCHAR2 타입의 요소

--변수 선언
    VARR1 VARR;
    NEST1 NEST;
    ASS1 IT_NUMBER;
    ASS2 IT_STR1;
    ASS3 IT_STR2;
BEGIN
    --변수에 값 할당
    VARR1:=VARR(1,10,100);
    NEST1:=NEST('A','B','C','D','E');
    ASS1(99):=20230329;
    ASS2(1):='연관배열 문자열';
    ASS3('HOPE'):='희망';
    ASS3('LOVE'):='사랑';
    
    --값을 읽기
    DBMS_OUTPUT.PUT_LINE(VARR1(1));
    DBMS_OUTPUT.PUT_LINE(NEST1(2));
    DBMS_OUTPUT.PUT_LINE(ASS1(99));
    DBMS_OUTPUT.PUT_LINE(ASS2(1));
    DBMS_OUTPUT.PUT_LINE(ASS3('LOVE'));
    DBMS_OUTPUT.PUT_LINE(ASS3('HOPE'));
END PROC_COLLECTION;

create or replace PROCEDURE PROC_COLL_METHOD
IS
    TYPE VA1 IS VARRAY(6) OF VARCHAR2(10);--가변 길이 배열
    TYPE NT1 IS TABLE OF VARCHAR2(20);--중첩테이블
    TYPE IT1 IS TABLE OF VARCHAR2(40) INDEX BY VARCHAR2(10);--연관배열
    VA_TEST VA1;
    NT_TEST NT1;
    IT_TEST IT1;
    
    V_CNT NUMBER:=0;
BEGIN
    IT_TEST('A'):='VALUE FOR A';
    IT_TEST('B'):='VALUE FOR B';
    IT_TEST('C'):='VALUE FOR C';
    V_CNT:=IT_TEST.COUNT;
    DBMS_OUTPUT.PUT_LINE('IT_TEST COUNT BEFORE DEL:'||V_CNT);
    IT_TEST.DELETE('A','B');
    V_CNT:=IT_TEST.COUNT;
    DBMS_OUTPUT.PUT_LINE('IT_TEST COUNT AFTER DEL:'||V_CNT);

    NT_TEST:=NT1('FIRST','SECOND','THIRD','FOURTH','FIFTH');
    NT_TEST.TRIM(2);
    DBMS_OUTPUT.PUT_LINE(NT_TEST(1));
    DBMS_OUTPUT.PUT_LINE(NT_TEST(2));
    DBMS_OUTPUT.PUT_LINE(NT_TEST(3));
--    DBMS_OUTPUT.PUT_LINE(NT_TEST(4));
--    DBMS_OUTPUT.PUT_LINE(NT_TEST(5));
    NT_TEST.EXTEND;
    DBMS_OUTPUT.PUT_LINE(NT_TEST(4));
    NT_TEST(4):='FOURTH';
    DBMS_OUTPUT.PUT_LINE(NT_TEST(4));
    NT_TEST.EXTEND(2,1);
    DBMS_OUTPUT.PUT_LINE(NT_TEST(1));
    DBMS_OUTPUT.PUT_LINE(NT_TEST(5));
    DBMS_OUTPUT.PUT_LINE(NT_TEST(6));
    
    VA_TEST:=VA1('1ST','2ND','3RD','4TH','5TH');
    FOR I IN VA_TEST.FIRST..VA_TEST.LAST
    LOOP
        DBMS_OUTPUT.PUT_LINE(I||'번째 요소 값:'||VA_TEST(I));
    END LOOP;
    DBMS_OUTPUT.PUT_LINE('VA COUNT:'||VA_TEST.COUNT);
    DBMS_OUTPUT.PUT_LINE('NT COUNT:'||NT_TEST.COUNT);
    DBMS_OUTPUT.PUT_LINE('VA LIMIT:'||VA_TEST.LIMIT);
    DBMS_OUTPUT.PUT_LINE('NT LIMIT:'||NT_TEST.LIMIT);
    
    DBMS_OUTPUT.PUT_LINE('FIRST:'||VA_TEST.FIRST);
    DBMS_OUTPUT.PUT_LINE('LAST:'||VA_TEST.LAST);
    DBMS_OUTPUT.PUT_LINE('FIRST PRIOR:'||VA_TEST.PRIOR(VA_TEST.FIRST));
    DBMS_OUTPUT.PUT_LINE('LAST NEXT:'||VA_TEST.NEXT(VA_TEST.LAST));
    DBMS_OUTPUT.PUT_LINE('INDEX 3 PRIOR:'||VA_TEST.PRIOR(3));
    DBMS_OUTPUT.PUT_LINE('INDEX 3 NEXT:'||VA_TEST.NEXT(3));

    IF NT_TEST.EXISTS(100) THEN
        DBMS_OUTPUT.PUT_LINE('있음');
    ELSE
        DBMS_OUTPUT.PUT_LINE('없음');
    END IF;
    
END PROC_COLL_METHOD;








